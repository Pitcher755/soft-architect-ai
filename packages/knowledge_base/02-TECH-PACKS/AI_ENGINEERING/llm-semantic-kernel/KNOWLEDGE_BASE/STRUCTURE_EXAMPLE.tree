# ðŸ“ Project Structure: Semantic Kernel Integration

> **PropÃ³sito:** PatrÃ³n de organizaciÃ³n de cÃ³digo para aplicaciones SK
> **FilosofÃ­a:** Plugin-Centric Architecture

---

## Estructura Recomendada

```
soft-architect-ai/
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ kernel_builder.py        # ðŸ­ Factory para crear Kernels configurados
â”‚   â”‚   â”œâ”€â”€ kernel_config.py         # âš™ï¸ ConfiguraciÃ³n centralizada
â”‚   â”‚   â””â”€â”€ service_setup.py         # ðŸ“‹ Registro de servicios (modelos, memoria)
â”‚   â”‚
â”‚   â”œâ”€â”€ plugins/                     # ðŸ§© Carpeta raÃ­z de Plugins
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ WriterPlugin/            # Plugin SemÃ¡ntico: Tareas de texto
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ Summarize/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ skprompt.txt     # Prompt template
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ config.json      # ParÃ¡metros (temp, max_tokens)
â”‚   â”‚   â”‚   â”œâ”€â”€ Translate/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ skprompt.txt
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ config.json
â”‚   â”‚   â”‚   â””â”€â”€ GenerateIdeas/
â”‚   â”‚   â”‚       â”œâ”€â”€ skprompt.txt
â”‚   â”‚   â”‚       â””â”€â”€ config.json
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ MathPlugin/              # Plugin Nativo: Operaciones deterministas
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ math_functions.py    # @kernel_function def add, subtract, multiply
â”‚   â”‚   â”‚   â””â”€â”€ calculator.py        # LÃ³gica auxiliar
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ DatabasePlugin/          # Plugin Nativo: Acceso a datos
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ db_functions.py      # @kernel_function def query, execute, fetch
â”‚   â”‚   â”‚   â””â”€â”€ models.py            # SQLAlchemy models o Pydantic schemas
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ SearchPlugin/            # Plugin HÃ­brido: SemÃ¡ntico + Nativo
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ Search/              # Semantic function
â”‚   â”‚       â”‚   â”œâ”€â”€ skprompt.txt
â”‚   â”‚       â”‚   â””â”€â”€ config.json
â”‚   â”‚       â””â”€â”€ search_functions.py  # Native: conecta con vectorstore
â”‚   â”‚
â”‚   â”œâ”€â”€ planners/                    # ðŸ“‹ ConfiguraciÃ³n de Planners
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ handlebars_setup.py      # HandlebarsPlanner configurado
â”‚   â”‚   â””â”€â”€ stepwise_setup.py        # StepwisePlanner (alternativa)
â”‚   â”‚
â”‚   â”œâ”€â”€ services/                    # ðŸŽ­ Capas de aplicaciÃ³n
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ agent_service.py         # OrquestaciÃ³n del Kernel + Planner
â”‚   â”‚   â”œâ”€â”€ chat_service.py          # Chat con historial
â”‚   â”‚   â””â”€â”€ task_service.py          # Ejecutar tareas complejas
â”‚   â”‚
â”‚   â””â”€â”€ infrastructure/              # ðŸ”§ Integraciones
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ memory/                  # Memoria connectors
â”‚       â”‚   â”œâ”€â”€ pinecone_memory.py   # Pinecone connector
â”‚       â”‚   â””â”€â”€ chroma_memory.py     # ChromaDB connector
â”‚       â””â”€â”€ llm/                     # LLM connectors
â”‚           â”œâ”€â”€ azure_openai.py      # Azure OpenAI
â”‚           â””â”€â”€ ollama.py            # Local Ollama
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ plugins/
â”‚   â”‚   â”œâ”€â”€ test_writer_plugin.py
â”‚   â”‚   â””â”€â”€ test_math_plugin.py
â”‚   â”‚
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ test_planner_e2e.py
â”‚
â””â”€â”€ pyproject.toml                    # ðŸ“¦ Dependencies (semantic-kernel, etc)

```

---

## Desglose por Responsabilidad

### `core/kernel_builder.py` - InstanciaciÃ³n

**PropÃ³sito:** Lugar Ãºnico donde se crean Kernels configurados.

```python
# core/kernel_builder.py
from semantic_kernel import Kernel
from semantic_kernel.connectors.ai.open_ai import AzureChatCompletion
from semantic_kernel.connectors.memory.pinecone import PineconeMemory

class KernelBuilder:
    @staticmethod
    def create_default_kernel(
        memory_namespace: str = "default"
    ) -> Kernel:
        """Crea un Kernel con configuraciÃ³n estÃ¡ndar."""
        kernel = Kernel()

        # Registrar servicio LLM
        kernel.add_service(
            AzureChatCompletion(
                deployment_name="gpt-4",
                model_id="gpt-4",
                api_key=os.getenv("AZURE_OPENAI_KEY")
            )
        )

        # Registrar memoria (Pinecone)
        kernel.add_memory(
            PineconeMemory(
                index_name="softarchitect",
                namespace=memory_namespace
            )
        )

        return kernel
```

### `plugins/{{PluginName}}/` - Plugin Organization

**PropÃ³sito:** Cada plugin es una carpeta con funciones relacionadas.

```
WriterPlugin/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ Summarize/
â”‚   â”œâ”€â”€ skprompt.txt
â”‚   â””â”€â”€ config.json
â””â”€â”€ Translate/
    â”œâ”€â”€ skprompt.txt
    â””â”€â”€ config.json

MathPlugin/
â”œâ”€â”€ __init__.py
â””â”€â”€ math_functions.py

```

**`plugins/WriterPlugin/__init__.py`:**

```python
from semantic_kernel.skill_definition import sk_function

class WriterPlugin:
    # No native functions aquÃ­ (si las hubiera)
    pass

def import_plugin(kernel):
    """Importa el plugin en el kernel."""
    kernel.import_semantic_skill_from_directory(
        "plugins",
        "WriterPlugin"
    )
```

### `planners/` - OrquestaciÃ³n

**PropÃ³sito:** Configurar planners que deciden quÃ© plugins usar.

```python
# planners/handlebars_setup.py
from semantic_kernel.planners import HandlebarsPlanner

async def create_planner(kernel):
    planner = HandlebarsPlanner(
        kernel,
        allow_missing_functions=False  # Strict
    )
    return planner
```

### `services/agent_service.py` - Punto de Entrada

**PropÃ³sito:** Orquesta Kernel + Planner + Plugins.

```python
# services/agent_service.py
from core.kernel_builder import KernelBuilder
from planners.handlebars_setup import create_planner

class AgentService:
    async def __init__(self, user_id: str):
        """Crea un agente por usuario (stateless request scope)."""
        self.kernel = KernelBuilder.create_default_kernel(
            memory_namespace=f"user_{user_id}"
        )
        self.planner = await create_planner(self.kernel)

    async def execute(self, goal: str):
        """Ejecuta un objetivo usando el Planner."""
        plan = await self.planner.create_plan(goal, max_iterations=5)
        return await plan.invoke(self.kernel)
```

### `infrastructure/memory/` - Vector DB Connectors

**PropÃ³sito:** Abstraer el tipo de vector store (Pinecone, Chroma, etc).

```python
# infrastructure/memory/pinecone_memory.py
class PineconeMemory:
    def __init__(self, index_name: str, namespace: str):
        self.client = Pinecone(api_key=os.getenv("PINECONE_KEY"))
        self.index = self.client.Index(index_name)
        self.namespace = namespace

    async def save_reference(self, key: str, value: str):
        """Guarda un vector en Pinecone."""
        embedding = generate_embedding(value)
        self.index.upsert(
            vectors=[(key, embedding)],
            namespace=self.namespace
        )

    async def recall(self, query: str):
        """Busca vectores similares."""
        query_embedding = generate_embedding(query)
        results = self.index.query(
            vector=query_embedding,
            namespace=self.namespace,
            top_k=5
        )
        return results
```

---

## Patrones de Uso

### Pattern 1: Goal-Oriented (Recomendado)

```
User Goal
    â†“
Kernel (servicios, memoria)
    â†“
HandlebarsPlanner
    â†“
Plugins (semÃ¡nticos + nativos)
    â†“
EjecuciÃ³n de plan
```

**ImplementaciÃ³n:**

```python
service = AgentService(user_id="user_123")
result = await service.execute("Summariza estos documentos y crea un plan de acciÃ³n")
```

### Pattern 2: Sequential Execution

```
Plugin A (semantic: summarize)
    â†“
Plugin B (native: analyze)
    â†“
Plugin C (semantic: generate report)
```

**ImplementaciÃ³n:**

```python
kernel = KernelBuilder.create_default_kernel()
step1 = await kernel.invoke_plugin_function("Writer", "Summarize", {"text": "..."})
step2 = await kernel.invoke_plugin_function("Math", "Analyze", {"data": step1})
step3 = await kernel.invoke_plugin_function("Writer", "GenerateReport", {"analysis": step2})
```

### Pattern 3: Nested Plugins

Un plugin invoca otros plugins.

```python
class OrchestratorPlugin:
    @kernel_function(description="Ejecuta un flujo completo")
    async def run_workflow(self, input: str):
        # Dentro, invoca otros plugins
        summary = await kernel.invoke_plugin_function(...)
        analysis = await kernel.invoke_plugin_function(...)
        return {"summary": summary, "analysis": analysis}
```

---

## Principios de DiseÃ±o

1. **Plugin Isolation:** Un plugin, una responsabilidad
2. **Kernel Stateless:** Cada request crea un kernel fresh
3. **Planner Limits:** Max iterations, timeout, sandbox
4. **Memory Isolation:** Namespaces para multi-tenancy
5. **Type Safety:** Type hints en funciones nativas

---

**Fecha:** 30 de Enero de 2026
**VersiÃ³n:** 1.0
**Status:** âœ… RECOMMENDED STRUCTURE
